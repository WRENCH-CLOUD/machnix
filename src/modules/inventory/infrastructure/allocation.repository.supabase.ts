import { BaseSupabaseRepository } from '@/shared/infrastructure/base-supabase.repository'
import { 
  AllocationStatus, 
  CreateAllocationInput, 
  InventoryAllocation,
  InventoryAllocationRow,
  AllocationDbUpdate,
  UpdateAllocationInput 
} from '../domain/allocation.entity'
import { AllocationRepository } from '../domain/allocation.repository'

export class SupabaseAllocationRepository extends BaseSupabaseRepository<InventoryAllocation, InventoryAllocationRow> implements AllocationRepository {
  
  protected toDomain(row: InventoryAllocationRow): InventoryAllocation {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      itemId: row.item_id,
      jobcardId: row.jobcard_id,
      estimateItemId: row.estimate_item_id ?? undefined,
      quantityReserved: Number(row.quantity_reserved),
      quantityConsumed: Number(row.quantity_consumed || 0),
      status: row.status,
      reservedAt: new Date(row.reserved_at),
      consumedAt: row.consumed_at ? new Date(row.consumed_at) : undefined,
      releasedAt: row.released_at ? new Date(row.released_at) : undefined,
      createdBy: row.created_by ?? undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    }
  }

  protected toDatabase(entity: Omit<InventoryAllocation, 'id' | 'createdAt' | 'updatedAt'>): InventoryAllocationRow {
    return {
      id: '', // Will be generated by DB
      tenant_id: entity.tenantId,
      item_id: entity.itemId,
      jobcard_id: entity.jobcardId,
      estimate_item_id: entity.estimateItemId ?? null,
      quantity_reserved: entity.quantityReserved,
      quantity_consumed: entity.quantityConsumed,
      status: entity.status,
      reserved_at: entity.reservedAt.toISOString(),
      consumed_at: entity.consumedAt?.toISOString() ?? null,
      released_at: entity.releasedAt?.toISOString() ?? null,
      created_by: entity.createdBy ?? null,
      created_at: '', // Will be generated by DB
      updated_at: '', // Will be generated by DB
    }
  }

  async findById(id: string): Promise<InventoryAllocation | null> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('id', id)
      .eq('tenant_id', tenantId)
      .maybeSingle()

    if (error) throw error
    return data ? this.toDomain(data) : null
  }

  async findByJobcardId(jobcardId: string): Promise<InventoryAllocation[]> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('jobcard_id', jobcardId)
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })

    if (error) throw error
    return (data || []).map(row => this.toDomain(row))
  }

  async findByItemId(itemId: string): Promise<InventoryAllocation[]> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('item_id', itemId)
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })

    if (error) throw error
    return (data || []).map(row => this.toDomain(row))
  }

  async findByEstimateItemId(estimateItemId: string): Promise<InventoryAllocation | null> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('estimate_item_id', estimateItemId)
      .eq('tenant_id', tenantId)
      .maybeSingle()

    if (error) throw error
    return data ? this.toDomain(data) : null
  }

  async findByStatus(status: AllocationStatus): Promise<InventoryAllocation[]> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('status', status)
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })

    if (error) throw error
    return (data || []).map(row => this.toDomain(row))
  }

  async findReservedByJobcard(jobcardId: string): Promise<InventoryAllocation[]> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('jobcard_id', jobcardId)
      .eq('status', 'reserved')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })

    if (error) throw error
    return (data || []).map(row => this.toDomain(row))
  }

  async findByItemAndJobcard(itemId: string, jobcardId: string): Promise<InventoryAllocation | null> {
    const tenantId = this.getContextTenantId()
    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('item_id', itemId)
      .eq('jobcard_id', jobcardId)
      .eq('status', 'reserved')
      .eq('tenant_id', tenantId)
      .maybeSingle()

    if (error) throw error
    return data ? this.toDomain(data) : null
  }

  async create(input: CreateAllocationInput): Promise<InventoryAllocation> {
    const tenantId = this.getContextTenantId()
    const dbInput = {
      tenant_id: tenantId,
      item_id: input.itemId,
      jobcard_id: input.jobcardId,
      estimate_item_id: input.estimateItemId,
      quantity_reserved: input.quantityReserved,
      quantity_consumed: 0,
      status: 'reserved',
      created_by: input.createdBy,
    }

    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .insert(dbInput)
      .select()
      .single()

    if (error) throw error
    return this.toDomain(data)
  }

  async update(id: string, input: UpdateAllocationInput): Promise<InventoryAllocation> {
    const tenantId = this.getContextTenantId()
    const updates: AllocationDbUpdate = {}
    
    if (input.quantityConsumed !== undefined) updates.quantity_consumed = input.quantityConsumed
    if (input.status !== undefined) updates.status = input.status
    if (input.consumedAt !== undefined) updates.consumed_at = input.consumedAt.toISOString()
    if (input.releasedAt !== undefined) updates.released_at = input.releasedAt.toISOString()

    const { data, error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .update(updates)
      .eq('id', id)
      .eq('tenant_id', tenantId)
      .select()
      .single()

    if (error) throw error
    return this.toDomain(data)
  }

  async markConsumed(id: string, quantityConsumed?: number): Promise<InventoryAllocation> {
    const allocation = await this.findById(id)
    if (!allocation) throw new Error(`Allocation ${id} not found`)
    
    const consumed = quantityConsumed ?? allocation.quantityReserved
    
    return this.update(id, {
      status: 'consumed',
      quantityConsumed: consumed,
      consumedAt: new Date(),
    })
  }

  async markReleased(id: string): Promise<InventoryAllocation> {
    return this.update(id, {
      status: 'released',
      releasedAt: new Date(),
    })
  }

  async releaseAllForJobcard(jobcardId: string): Promise<number> {
    const tenantId = this.getContextTenantId()
    
    // Get all reserved allocations for this job
    const reservedAllocations = await this.findReservedByJobcard(jobcardId)
    
    if (reservedAllocations.length === 0) return 0

    // Update all to released
    const { error } = await this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .update({
        status: 'released',
        released_at: new Date().toISOString(),
      })
      .eq('jobcard_id', jobcardId)
      .eq('status', 'reserved')
      .eq('tenant_id', tenantId)

    if (error) throw error
    return reservedAllocations.length
  }

  /**
   * Get allocations with related item and job details
   * Note: Uses separate queries since there are no FK relationships defined
   */
  async findWithRelations(status?: AllocationStatus, limit: number = 50): Promise<{
    id: string
    itemId: string
    itemName: string
    jobcardId: string
    jobNumber: string
    quantityReserved: number
    quantityConsumed: number
    status: AllocationStatus
    reservedAt: Date
    consumedAt?: Date
    releasedAt?: Date
  }[]> {
    const tenantId = this.getContextTenantId()
    
    // First, get allocations
    let query = this.supabase
      .schema('tenant')
      .from('inventory_allocations')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('reserved_at', { ascending: false })
      .limit(limit)

    if (status) {
      query = query.eq('status', status)
    }

    const { data: allocations, error: allocError } = await query
    if (allocError) throw allocError
    if (!allocations || allocations.length === 0) return []

    // Get unique item IDs and jobcard IDs
    const itemIds = [...new Set(allocations.map(a => a.item_id))]
    const jobcardIds = [...new Set(allocations.map(a => a.jobcard_id))]

    // Fetch items
    const { data: items, error: itemsError } = await this.supabase
      .schema('tenant')
      .from('inventory_items')
      .select('id, name')
      .in('id', itemIds)
      .eq('tenant_id', tenantId)

    if (itemsError) throw itemsError
    const itemMap = new Map((items || []).map(i => [i.id, i.name]))

    // Fetch jobcards
    const { data: jobcards, error: jobcardsError } = await this.supabase
      .schema('tenant')
      .from('jobcards')
      .select('id, job_number')
      .in('id', jobcardIds)
      .eq('tenant_id', tenantId)

    if (jobcardsError) throw jobcardsError
    const jobcardMap = new Map((jobcards || []).map(j => [j.id, j.job_number]))

    // Map and return combined data
    return allocations.map((row: any) => ({
      id: row.id,
      itemId: row.item_id,
      itemName: itemMap.get(row.item_id) || 'Unknown',
      jobcardId: row.jobcard_id,
      jobNumber: jobcardMap.get(row.jobcard_id) || 'Unknown',
      quantityReserved: Number(row.quantity_reserved),
      quantityConsumed: Number(row.quantity_consumed || 0),
      status: row.status as AllocationStatus,
      reservedAt: new Date(row.reserved_at),
      consumedAt: row.consumed_at ? new Date(row.consumed_at) : undefined,
      releasedAt: row.released_at ? new Date(row.released_at) : undefined,
    }))
  }
}
